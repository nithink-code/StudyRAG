import asyncio
from pathlib import Path
import time
import os
import requests

import streamlit as st
import inngest
from dotenv import load_dotenv


try:
    import pypdf
except ImportError:
    pypdf = None

load_dotenv()

# --- Page Configuration ---
st.set_page_config(
    page_title="StudyRAG Assistant",
    page_icon="üéì",
    layout="centered",
    initial_sidebar_state="collapsed"
)

# --- Load Custom CSS ---
def local_css(file_name):
    # Resolve path relative to this script file to avoid CWD issues
    css_file = Path(__file__).parent / file_name
    with open(css_file, encoding="utf-8") as f:
        st.markdown(f'<style>{f.read()}</style>', unsafe_allow_html=True)

local_css("style.css")

# --- Logic / Helpers ---

def get_inngest_client() -> inngest.Inngest:
    return inngest.Inngest(
        app_id="study-rag", 
        is_production=os.getenv("INNGEST_DEV") is None,
        signing_key=os.getenv("INNGEST_SIGNING_KEY"),
        event_key=os.getenv("INNGEST_EVENT_KEY")
    )

async def send_rag_ingest_event(pdf_text: str, file_name: str) -> None:
    client = get_inngest_client()
    await client.send(
        inngest.Event(
            name="rag/ingest-pdf",
            data={
                "text": pdf_text,
                "source_id": file_name,
            },
        )
    )

async def send_rag_query_event(question: str, top_k: int) -> str:
    """Returns the event ID generated by Inngest."""
    client = get_inngest_client()
    result = await client.send(
        inngest.Event(
            name="rag/query-pdf",
            data={
                "question": question,
                "top_k": top_k,
            },
        )
    )
    # The result of client.send is a list of event IDs
    return result[0]

def _inngest_api_base() -> str:
    # Local dev server default; configurable via env
    return os.getenv("INNGEST_API_BASE", "https://api.inngest.com/v1")

def fetch_runs(event_id: str) -> list[dict]:
    url = f"{_inngest_api_base()}/events/{event_id}/runs"
    headers = {}
    signing_key = os.getenv("INNGEST_SIGNING_KEY")
    if signing_key:
        headers["Authorization"] = f"Bearer {signing_key}"
    
    try:
        resp = requests.get(url, headers=headers)
        resp.raise_for_status()
        data = resp.json()
        return data.get("data", [])
    except Exception:
        return []

def wait_for_run_output(event_id: str, timeout_s: float = 300.0, poll_interval_s: float = 1.0) -> dict:
    start = time.time()
    last_status = None
    while True:
        runs = fetch_runs(event_id)
        if runs:
            run = runs[0]
            status = run.get("status")
            last_status = status or last_status
            if status in ("Completed", "Succeeded", "Success", "Finished"):
                return run.get("output") or {}
            if status in ("Failed", "Cancelled"):
                raise RuntimeError(f"Function run {status}")
        
        if time.time() - start > timeout_s:
            raise TimeoutError(f"Timed out waiting for run output (last status: {last_status})")
        
        time.sleep(poll_interval_s)



def show_toast(message):
    st.markdown(f"""
    <div class="success-toast">
        <div class="success-icon">‚úì</div>
        {message}
    </div>
    """, unsafe_allow_html=True)

def tab_upload():
    st.markdown("""
    <div class="animated-border-box">
        <div class="animated-border-box-content">
            <h3 style="margin-top:0;">üìÇ Upload Knowledge Base</h3>
            <p style="color: #aaa; margin-bottom: 20px;">
                Drag and drop your PDF documents here. The AI will analyze them and prepare them for your questions.
            </p>
        </div>
    </div>
    """, unsafe_allow_html=True)
    
    col1, col2, col3 = st.columns([1, 8, 1])
    with col2:
        uploaded = st.file_uploader(" ", type=["pdf"], accept_multiple_files=False, label_visibility="collapsed")
        
        if uploaded is not None:
            if pypdf is None:
                st.error("‚ùå `pypdf` is missing. Please add it to `requirements.txt`.")
            else:
                st.info(f"Selected: **{uploaded.name}**")
                if st.button("üöÄ Process System Initiation", use_container_width=True):
                    with st.status("Analyzing document structure...", expanded=True) as status:
                        try:
                            st.write("üìñ Parsing binary data...")
                            reader = pypdf.PdfReader(uploaded)
                            text = ""
                            for page in reader.pages:
                                text += page.extract_text() + "\n"
                            
                            st.write("üì§ Synchronizing with Neural Network...")
                            asyncio.run(send_rag_ingest_event(text, uploaded.name))
                            
                            status.update(label="‚úÖ Integration Complete!", state="complete", expanded=False)
                            
                            # Custom Toast
                            show_toast(f"System successfully integrated: {uploaded.name}")
                            
                            # Wait briefly then redirect
                            time.sleep(1.5)
                            st.session_state["active_tab"] = "chat"
                            st.rerun()

                        except Exception as e:
                            status.update(label="‚ùå System Error", state="error")
                            st.error(f"Error processing PDF: {e}")
    
    # Document Management Section
    st.markdown("<br>", unsafe_allow_html=True)
    st.markdown("""
    <div class="animated-border-box">
        <div class="animated-border-box-content">
            <h3 style="margin-top:0;">üóÇÔ∏è Manage Knowledge Base</h3>
            <p style="color: #aaa; margin-bottom: 20px;">
                View and manage documents currently stored in the system.
            </p>
        </div>
    </div>
    """, unsafe_allow_html=True)
    
    col1, col2, col3 = st.columns([1, 8, 1])
    with col2:
        try:
            from vector_db import QdrantStorage
            storage = QdrantStorage()
            sources = storage.get_all_sources()
            
            if sources:
                st.write(f"**üìö Stored Documents ({len(sources)}):**")
                for source in sources:
                    col_a, col_b = st.columns([7, 3])
                    with col_a:
                        st.write(f"‚Ä¢ {source}")
                    with col_b:
                        if st.button(f"üóëÔ∏è Delete", key=f"del_{source}", use_container_width=True):
                            with st.spinner(f"Removing {source}..."):
                                storage.delete_by_source(source)
                                st.success(f"‚úÖ Deleted: {source}")
                                time.sleep(1)
                                st.rerun()
                
                st.markdown("<br>", unsafe_allow_html=True)
                if st.button("üóëÔ∏è Clear All Documents", use_container_width=True, type="secondary"):
                    if st.session_state.get("confirm_clear"):
                        with st.spinner("Clearing all documents..."):
                            storage.clear_collection()
                            st.success("‚úÖ All documents cleared!")
                            st.session_state["confirm_clear"] = False
                            time.sleep(1)
                            st.rerun()
                    else:
                        st.session_state["confirm_clear"] = True
                        st.warning("‚ö†Ô∏è Click again to confirm deletion of ALL documents")
                        st.rerun()
            else:
                st.info("üì≠ No documents stored yet. Upload a PDF to get started!")
                
        except ConnectionError as e:
            st.error(f"‚ùå **Connection Error**: {e}")
            st.info("""
            **Troubleshooting Steps:**
            1. Check your internet connection
            2. Verify `QDRANT_URL` in your `.env` file is correct
            3. Ensure your Qdrant cloud instance is running
            4. Check if a firewall or proxy is blocking the connection
            """)
        except Exception as e:
            st.error(f"‚ùå **Error loading documents**: {e}")
            st.info("If this persists, try restarting the application or check your Qdrant configuration.")

def tab_chat():
    # Animated Border Container for Chat Header
    st.markdown("""
    <div class="animated-border-box">
        <div class="animated-border-box-content">
            <h3 style="margin-top:0;">üí¨ Neural Interface</h3>
            <p style="color: #aaa; margin-bottom: 0px;">
                Interact with your processed documents. Adjust the retrieval precision below.
            </p>
        </div>
    </div>
    """, unsafe_allow_html=True)
    
    # Settings inline instead of sidebar
    with st.expander("‚öôÔ∏è Retrieval Configuration"):
        top_k = st.slider("Context Precision (Top-K Chunks)", min_value=1, max_value=20, value=5)
    
    # Initialize session state for chat history
    if "messages" not in st.session_state:
        st.session_state.messages = []

    # Display chat messages with custom styling
    st.markdown('<div class="chat-container">', unsafe_allow_html=True)
    for message in st.session_state.messages:
        role_class = "user-message" if message["role"] == "user" else "assistant-message"
        st.markdown(f"""
        <div class="{role_class}">
            {message["content"]}
        </div>
        """, unsafe_allow_html=True)
    st.markdown('</div>', unsafe_allow_html=True)

    # Chat input
    if prompt := st.chat_input("Input command or query..."):
        # Add user message to history
        st.session_state.messages.append({"role": "user", "content": prompt})
        
        # Generate response
        with st.spinner("Processing query vector..."):
            try:
                # Trigger the RAG query
                event_id = asyncio.run(send_rag_query_event(prompt, top_k))
                
                # Wait for the result
                output = wait_for_run_output(event_id)
                answer = output.get("answer", "I couldn't find an answer.")
                sources = output.get("sources", [])
                
                # Format response with sources
                full_response = answer
                if sources:
                    full_response += "<br><br><small><strong>Sources:</strong><ul>" + "".join([f"<li>{s}</li>" for s in sources]) + "</ul></small>"
                
                # Add assistant response to history
                st.session_state.messages.append({"role": "assistant", "content": full_response})
                
                # Force rerun to display new messages
                st.rerun()
                    
            except Exception as e:
                error_msg = f"System Malfunction: {str(e)}"
                st.session_state.messages.append({"role": "assistant", "content": error_msg})
                st.rerun()

# --- Main Layout ---

def main():
    # Main Header Animation
    st.markdown('<h1 class="main-title">StudyRAG</h1>', unsafe_allow_html=True)
    st.markdown('<p class="subtitle">Advanced Intelligent Document Analysis System</p>', unsafe_allow_html=True)
    
    # Navigation State
    if "active_tab" not in st.session_state:
        st.session_state["active_tab"] = "upload"

    # Custom Navigation Bar
    col1, col2 = st.columns(2)
    with col1:
        if st.button("üìÇ DATA INGESTION", use_container_width=True, type="primary" if st.session_state["active_tab"] == "upload" else "secondary"):
            st.session_state["active_tab"] = "upload"
            st.rerun()
    with col2:
        if st.button("üí¨ NEURAL CHAT", use_container_width=True, type="primary" if st.session_state["active_tab"] == "chat" else "secondary"):
            st.session_state["active_tab"] = "chat"
            st.rerun()
            
    st.markdown("<br>", unsafe_allow_html=True)

    placeholder = st.empty()
    
    if st.session_state["active_tab"] == "upload":
        tab_upload()
    elif st.session_state["active_tab"] == "chat":
        tab_chat()
if __name__ == "__main__":
    main()
